/*
*	author : Mirco Palese
*	program name : s27
*	last edit :	
*	description : 
*	note : 	filedes[2] = read end of the pipe 
			filedes[1] = write end of the pipe
*
*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include "../../include/apue.h"


#define MIN_PLENGHT 5	/* first 4 bytes are for the bytenum at the beginning of the pack */
#define MAX_PLENGHT 24 	/* first 4 bytes are for the bytenum at the beginning of the pack */





int generate_pack();
void sigint_handler(int dummy);



unsigned char *pack = NULL;
pid_t pid;
/* real max length and real minlength are correspondent effective ones + 4 */

int main (int argc , char *argv[]){

	int filedes[2];
	char *path = "./pack_recv";
	
	
	signal(SIGINT, sigint_handler); /* installing signal handler */
	srand(time(NULL)); 
	if( pipe(filedes) == -1) err_sys("pipe error ");	/* pipe opening */
	
	if( (pid = vfork()) == -1 )err_sys("fork error ");
	else if(pid == 0){
		execl(path,"pack_recv",(void*)0);
		exit(0);
	}
	else if(pid > 0) close(filedes[0]);	/* closing read end of the pipe */
	
	/* generate 1 pack every second */
	for(;;){
		int bytenum = generate_pack();
		if( write(filedes[1],pack,bytenum) != bytenum) err_sys("write error ");
		sleep(1);
	}
	
	
	wait(NULL);
	
	return 0;
	
}




/* generate packet made by random bytes */
int generate_pack(){
	int bytenum = (rand() % ( MAX_PLENGHT - MIN_PLENGHT + 1)) + MIN_PLENGHT; /* packet's bytenum = packet length*/
	unsigned char bytenum_c [4]; 		/* 
										* (char) bytenum, because of type of pack that is
										* unsigned char, so we have to to convert the 4 bytes
										* of the int into a char before to put it in the packet.
										*/
	memcpy(&bytenum_c,&bytenum,4);		/* copying the 4 bytes of (int) bytenum inside (char) bytenum_c */										
	pack = realloc (pack,bytenum); 		/* allocating memory for the pack */
	
		
		
	/* inserting the int converted to char inside the 4 first bytes of pack */
	pack[0] = bytenum_c[0];
	pack[1] = bytenum_c[1];
	pack[2] = bytenum_c[2];
	pack[3] = bytenum_c[3];
	
	/* 
	* filling remaining bytes of pack, starting from pack[4] ( 4 bytes are for the initial bytenum),
	* with randomly generated bytes 
	*/
	for(int i = 4; i < bytenum; i++){
		unsigned char byte = (rand() % 256); /* 1 byte can contains int between 0 and 256 */
		pack[i] = byte;
	}
	
	return bytenum;	 
}


/* 
* sigint handler. When ^c is received, the child was closed
* wait function return and this process terminate
*/
void sigint_handler(int dummy){
	if ( kill(pid, SIGINT) == -1) err_sys("kill error\n");
	printf("child killed\n");
	exit(0);
}
 






